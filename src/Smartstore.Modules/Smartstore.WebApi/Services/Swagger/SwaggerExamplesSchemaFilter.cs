using System.Collections.Concurrent;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Text.Json.Serialization;
using Microsoft.OpenApi.Any;
using Microsoft.OpenApi.Models;
using Newtonsoft.Json;
using Swashbuckle.AspNetCore.SwaggerGen;

namespace Smartstore.Web.Api.Swagger;

/* 
 TODO: (mg) 
    - INFO: Never copy/paste AI generated code without checking and adjusting to our common coding practices!
    - Very bad architecture:
        - TypeMemberMapCache is far too greedy and cosumes memory for all types ever processed, BUT...
        - ... PruneSchemaProperties() ALWAYS processes attributes and checks other stuff on demand. What is caching good for then?!
        - Everything belongs to the cache, or don't cache at all! Or cache only the minimum needed info (e.g. ignored properties only).
        - DRY: IgnoreDataMember, DataMember and other stuff are already processed by SmartJsonOption.WithDataContractModifiers(),
          so ideally we should reuse that info instead of re-reflecting everything here again?
            - To access that info, we call JsonSerializerOptions.GetTypeInfo(type) (we obtain the options via DI: IOptions<JsonOptions>.Value...)
            - But then, the originally lazy-loaded JSON type resolution will process EVERY type on startup, killing startup performance? Hmmm...?
        - How do you distinguish between SwaggerSchemaFilter and SwaggerExamplesSchemaFilter (how do you know that we are processing "Examples" right now?)?
        - Sometimes SingleResult<T> is pruned. Unwrapping fail?
        - Maybe SmartSerializerDataContractResolver is the better place to hook into? Hmmm...
    - NiceToHave: Consider using some [SwaggerSchemaExample] attributes on properties to override examples on a per-property basis.
 */
/*
RE: In this case, it was my intention not to change anything here. I don't want to invest any more time in these Swashbuckle implementations. 
I've already invested far too much time in them. At the moment, I'm assuming that Swashbuckle will be removed. See Issue #1389. 
If the examples filters are problematic or not wanted like this, we have theses options:
- Undo my commit -> still use Swashbuckle.AspNetCore.Newtonsoft
- Throw them away -> huge examples that contains the whole schema graph
- Use the commented-out SwaggerExampleSchemaFilter at the bottom of this file and remove SwaggerExamplesOperationFilter 
  -> simple but flat JSON examples without any EF navigation properties.
 */

/// <summary>
/// Generated by ChatGPT. Provides the JSON formatted examples in Swagger documentation.
/// Without this filter the example would display the whole schema graph, which is much to deep and impractical or unusable for humans.
/// </summary>
/// <remarks>Deepseek does not provide an adequate solution for this.</remarks>
internal sealed class SwaggerExamplesSchemaFilter : ISchemaFilter
{
    internal const int MaxDepth = 1;
    internal const int MaxPropsPerObject = 1000;
    internal const int MaxArrayItems = 1;

    // Extend as needed ("Foo*" supported)
    internal static readonly string[] ExcludedPropertyNamePatterns = ["UnderlyingEntities"];

    // Cache: CLR Type -> ignored serialized names (small & sufficient)
    private static readonly ConcurrentDictionary<Type, HashSet<string>> IgnoredMembersCache = new();

    public void Apply(OpenApiSchema schema, SchemaFilterContext context)
    {
        if (schema == null || context == null)
            return;

        // 1) Schema tab: never show any example (like Newtonsoft support did)
        // TODO: (mg) I don't see any difference in Swagger-UI-behaviour between NSJ and STJ. Hmmm...
        // RE: Yes, that was the goal. To get as close as possible to the result when using Swashbuckle.AspNetCore.Newtonsoft.
        schema.Example = null;

        // 2) Schema properties: remove ignored stuff (so it disappears from "Schema" property list)
        PruneSchemaProperties(schema, context.SchemaRepository, context.Type);
    }

    internal static IOpenApiAny BuildExample(OpenApiSchema rootSchema, SchemaRepository repo, Type rootClrType)
    {
        var visitedTypes = new HashSet<Type>();
        return BuildAny(rootSchema, repo, MaxDepth, (rootClrType ?? typeof(object)).GetNonNullableType(), visitedTypes);
    }

    private static IOpenApiAny BuildAny(OpenApiSchema schema, SchemaRepository repo, int depthRemaining, Type typeHint, HashSet<Type> visitedTypes)
    {
        schema = ResolveRef(schema, repo);

        var clrType = (typeHint ?? typeof(object)).GetNonNullableType();

        if (depthRemaining < 0)
            return CompactPlaceholder(schema, repo, clrType);

        // Guard cycles only for complex entity-ish types
        if (ShouldGuardType(clrType))
        {
            if (!visitedTypes.Add(clrType))
                return CompactPlaceholder(schema, repo, clrType);

            try
            {
                return BuildAnyCore(schema, repo, depthRemaining, clrType, visitedTypes);
            }
            finally
            {
                visitedTypes.Remove(clrType);
            }
        }

        return BuildAnyCore(schema, repo, depthRemaining, clrType, visitedTypes);
    }

    private static IOpenApiAny BuildAnyCore(OpenApiSchema schema, SchemaRepository repo, int depthRemaining, Type clrType, HashSet<Type> visitedTypes)
    {
        if (schema?.Enum != null && schema.Enum.Count > 0)
            return schema.Enum[0];

        // Arrays/collections ALWAYS render as arrays (prevents Count/IsReadOnly/Length etc.)
        if (clrType.IsSequenceType(out var elementType) || (schema != null && (schema.Type == "array" || schema.Items != null)))
        {
            var itemSchema = (schema != null && schema.Items != null) ? schema.Items : new OpenApiSchema { Type = "string" };
            var et = elementType ?? typeof(object);

            var arr = new OpenApiArray();
            for (var i = 0; i < MaxArrayItems; i++)
            {
                // Arrays do not consume depth
                arr.Add(BuildAny(itemSchema, repo, depthRemaining, et, visitedTypes));
            }
            return arr;
        }

        // Dictionary-like
        if (clrType.IsDictionaryType() || (schema != null && schema.AdditionalProperties != null && (schema.Properties == null || schema.Properties.Count == 0)))
        {
            return CreateAdditionalProps(new OpenApiString("string"));
        }

        // primitives
        if (IsPrimitiveSchema(schema))
            return CreatePrimitiveExampleFromSchema(schema);

        if (IsSimpleClr(clrType))
            return CreatePrimitiveExampleFromClr(clrType, schema);

        // objects
        return BuildObjectExample(schema, repo, depthRemaining, clrType, visitedTypes);
    }

    private static OpenApiObject BuildObjectExample(OpenApiSchema schema, SchemaRepository repo, int depthRemaining, Type clrType, HashSet<Type> visitedTypes)
    {
        // additionalProperties-only
        if (schema != null &&
            schema.AdditionalProperties != null &&
            (schema.Properties == null || schema.Properties.Count == 0) &&
            (schema.AllOf == null || schema.AllOf.Count == 0))
        {
            return CreateAdditionalProps(BuildAny(schema.AdditionalProperties, repo, depthRemaining - 1, typeof(object), visitedTypes));
        }

        var props = GetEffectiveProperties(schema, repo);
        var ignored = GetIgnoredMembers(clrType);

        if (props == null || props.Count == 0)
        {
            // no schema props -> reflect CLR (still filtered)
            return BuildObjectFromReflection(clrType, repo, depthRemaining, visitedTypes);
        }

        var obj = new OpenApiObject();

        foreach (var kvp in props.Take(MaxPropsPerObject))
        {
            var name = kvp.Key;

            if (ShouldExcludeByName(name) || ignored.Contains(name))
                continue;

            var memberType = GetMostDerivedProperty(clrType, name)?.PropertyType ?? typeof(object);
            obj[name] = BuildAny(kvp.Value, repo, depthRemaining - 1, memberType, visitedTypes);
        }

        return obj;
    }

    private static OpenApiObject BuildObjectFromReflection(Type clrType, SchemaRepository repo, int depthRemaining, HashSet<Type> visitedTypes)
    {
        clrType = (clrType ?? typeof(object)).GetNonNullableType();

        if (clrType.IsSequenceType() || clrType.IsDictionaryType())
            return [];

        if (depthRemaining < 0)
            return BuildCompactObjectFromClr(clrType);

        var flags = BindingFlags.Instance | BindingFlags.Public;
        var obj = new OpenApiObject();

        foreach (var p in clrType.GetProperties(flags))
        {
            if (obj.Count >= MaxPropsPerObject)
                break;

            if (p.GetIndexParameters().Length > 0)
                continue;

            // Do not include interface-declared members
            if (p.DeclaringType != null && p.DeclaringType.IsInterface)
                continue;

            if (p.IsDefined(typeof(IgnoreDataMemberAttribute), true))
                continue;

            if (ShouldExcludeByName(p.Name))
                continue;

            obj[p.Name] = BuildAny(new OpenApiSchema(), repo, depthRemaining - 1, p.PropertyType, visitedTypes);
        }

        return obj.Count > 0 ? obj : BuildCompactObjectFromClr(clrType);
    }

    private static IOpenApiAny CompactPlaceholder(OpenApiSchema schema, SchemaRepository repo, Type clrType)
    {
        if (clrType.IsSequenceType(out var elementType) || (schema != null && (schema.Type == "array" || schema.Items != null)))
        {
            var arr = new OpenApiArray();
            if (MaxArrayItems > 0)
            {
                var itemSchema = (schema != null && schema.Items != null) ? schema.Items : new OpenApiSchema { Type = "string" };
                var et = elementType ?? typeof(object);

                if (IsSimpleClr(et))
                    arr.Add(CreatePrimitiveExampleFromClr(et, itemSchema));
                else
                    arr.Add(BuildCompactObjectFromClr(et));
            }
            return arr;
        }

        if (IsPrimitiveSchema(schema))
            return CreatePrimitiveExampleFromSchema(schema);

        if (IsSimpleClr(clrType))
            return CreatePrimitiveExampleFromClr(clrType, schema);

        return BuildCompactObjectFromClr(clrType);
    }

    private static OpenApiObject BuildCompactObjectFromClr(Type clrType)
    {
        var obj = new OpenApiObject();
        clrType = (clrType ?? typeof(object)).GetNonNullableType();

        var ignored = GetIgnoredMembers(clrType);

        var id = GetMostDerivedProperty(clrType, "Id");
        if (id != null && !ignored.Contains("Id") && !ShouldExcludeByName("Id") && !id.IsDefined(typeof(IgnoreDataMemberAttribute), true))
            obj["Id"] = CreatePrimitiveExampleFromClr(id.PropertyType, null);

        var name = GetMostDerivedProperty(clrType, "Name");
        if (name != null && !ignored.Contains("Name") && !ShouldExcludeByName("Name") && !name.IsDefined(typeof(IgnoreDataMemberAttribute), true))
            obj["Name"] = CreatePrimitiveExampleFromClr(name.PropertyType, null);

        return obj;
    }

    private static void PruneSchemaProperties(OpenApiSchema schema, SchemaRepository repo, Type clrType)
    {
        if (schema == null || clrType == null)
            return;

        // If the schema is actually a collection, don't treat it as object properties
        if (clrType.IsSequenceType() || clrType.IsDictionaryType())
            return;

        var ignored = GetIgnoredMembers(clrType);

        // Walk schema + inline allOf/oneOf/anyOf parts; also follow $ref
        var visited = new HashSet<OpenApiSchema>(ReferenceEqualityComparer.Instance);
        var stack = new Stack<OpenApiSchema>();
        stack.Push(schema);

        while (stack.Count > 0)
        {
            var current = stack.Pop();
            if (current == null)
                continue;

            current = ResolveRef(current, repo);
            if (current == null || !visited.Add(current))
                continue;

            // Schema tab should never show any example anywhere
            current.Example = null;

            if (current.Properties != null && current.Properties.Count > 0)
            {
                var toRemove = new List<string>();

                foreach (var kv in current.Properties)
                {
                    var name = kv.Key;

                    if (ShouldExcludeByName(name) || ignored.Contains(name))
                        toRemove.Add(name);
                }

                for (var i = 0; i < toRemove.Count; i++)
                {
                    var n = toRemove[i];
                    current.Properties.Remove(n);
                    current.Required?.Remove(n);
                }
            }

            if (current.AllOf != null)
                foreach (var s in current.AllOf) stack.Push(s);

            if (current.OneOf != null)
                foreach (var s in current.OneOf) stack.Push(s);

            if (current.AnyOf != null)
                foreach (var s in current.AnyOf) stack.Push(s);
        }
    }

    private sealed class ReferenceEqualityComparer : IEqualityComparer<OpenApiSchema>
    {
        public static readonly ReferenceEqualityComparer Instance = new();

        public bool Equals(OpenApiSchema x, OpenApiSchema y) => ReferenceEquals(x, y);
        public int GetHashCode(OpenApiSchema obj) => RuntimeHelpers.GetHashCode(obj);
    }

    private static OpenApiSchema ResolveRef(OpenApiSchema schema, SchemaRepository repo)
    {
        if (schema?.Reference == null || schema.Reference.Id.IsEmpty())
            return schema;

        if (repo?.Schemas != null && repo.Schemas.TryGetValue(schema.Reference.Id, out var resolved) && resolved != null)
            return resolved;

        return schema;
    }

    private static IDictionary<string, OpenApiSchema> GetEffectiveProperties(OpenApiSchema schema, SchemaRepository repo)
    {
        if (schema == null)
            return null;

        if (schema.Properties != null && schema.Properties.Count > 0)
            return schema.Properties;

        if (schema.AllOf == null || schema.AllOf.Count == 0)
            return schema.Properties;

        var merged = new Dictionary<string, OpenApiSchema>(StringComparer.OrdinalIgnoreCase);

        foreach (var part in schema.AllOf)
        {
            var s = ResolveRef(part, repo);
            if (s?.Properties == null)
                continue;

            merged.Merge(s.Properties);
        }

        if (schema.Properties != null)
        {
            merged.Merge(schema.Properties);
        }

        return merged.Count > 0 ? merged : null;
    }

    private static bool IsPrimitiveSchema(OpenApiSchema schema)
    {
        if (schema == null)
            return false;

        var type = schema.Type;
        return type == "string" || type == "integer" || type == "number" || type == "boolean";
    }

    private static IOpenApiAny CreatePrimitiveExampleFromSchema(OpenApiSchema schema)
    {
        switch (schema?.Type ?? string.Empty)
        {
            case "boolean":
                return new OpenApiBoolean(true);
            case "integer":
                return new OpenApiInteger(0);
            case "number":
                return new OpenApiDouble(0);
            case "array":
                return new OpenApiArray();
            case "object":
                return new OpenApiObject();
        }

        switch (schema?.Format ?? string.Empty)
        {
            case "date-time":
                return new OpenApiString("2026-01-01T00:00:00Z");
            case "date":
                return new OpenApiString("2026-01-01");
            case "uuid":
                return new OpenApiString("3fa85f64-5717-4562-b3fc-2c963f66afa6");
            case "email":
                return new OpenApiString("user@example.com");
            case "uri":
                return new OpenApiString("https://example.com");
            case "byte":
                return new OpenApiByte(0);
            default:
                return new OpenApiString("string");
        }
    }

    private static IOpenApiAny CreatePrimitiveExampleFromClr(Type t, OpenApiSchema schema)
    {
        t = (t ?? typeof(string)).GetNonNullableType();

        if (t.IsEnum)
        {
            var names = Enum.GetNames(t);
            return new OpenApiString(names.FirstOrDefault() ?? "Value");
        }

        if (t == typeof(bool))
            return new OpenApiBoolean(true);

        if (t == typeof(int) || t == typeof(long) || t == typeof(short) || t == typeof(byte))
            return new OpenApiInteger(0);

        if (t == typeof(float) || t == typeof(double) || t == typeof(decimal))
            return new OpenApiDouble(0);

        if (t == typeof(DateTime) || t == typeof(DateTimeOffset))
            return new OpenApiString("2026-01-01T00:00:00Z");

        if (t == typeof(Guid))
            return new OpenApiString("3fa85f64-5717-4562-b3fc-2c963f66afa6");

        if (t == typeof(Uri))
            return new OpenApiString("https://example.com");

        if (t == typeof(string) && schema != null && !string.IsNullOrWhiteSpace(schema.Format))
            return CreatePrimitiveExampleFromSchema(schema);

        return new OpenApiString("string");
    }

    private static OpenApiObject CreateAdditionalProps(IOpenApiAny value)
    {
        return new()
        {
            ["additionalProp1"] = value,
            ["additionalProp2"] = value
        };
    }

    private static bool IsSimpleClr(Type t)
    {
        if (t == null)
            return false;

        t = t.GetNonNullableType();

        if (t == typeof(Uri))
            return true;

        return t.IsBasicType() && t != typeof(byte[]);
    }

    private static bool ShouldGuardType(Type t)
    {
        if (t == null || t == typeof(object) || IsSimpleClr(t) || t.IsSequenceType() || t.IsDictionaryType())
            return false;

        return t.IsClass;
    }

    private static bool ShouldExcludeByName(string propertyName)
    {
        if (ExcludedPropertyNamePatterns == null || ExcludedPropertyNamePatterns.Length == 0)
            return false;

        for (var i = 0; i < ExcludedPropertyNamePatterns.Length; i++)
        {
            var p = ExcludedPropertyNamePatterns[i];
            if (p.IsEmpty())
                continue;

            if (p.EndsWith('*'))
            {
                var prefix = p[..^1];
                if (propertyName.StartsWithNoCase(prefix))
                    return true;
            }
            else
            {
                if (propertyName.EqualsNoCase(p))
                    return true;
            }
        }

        return false;
    }

    private static int DistanceTo(Type rootType, Type declaringType)
    {
        var d = 0;
        for (var t = rootType; t != null; t = t.BaseType, d++)
        {
            if (t == declaringType)
                return d;
        }
        return int.MaxValue;
    }

    private static HashSet<string> GetIgnoredMembers(Type clrType)
    {
        clrType = (clrType ?? typeof(object)).GetNonNullableType();

        return IgnoredMembersCache.GetOrAdd(clrType, static t =>
        {
            var set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            var flags = BindingFlags.Instance | BindingFlags.Public;

            foreach (var p in t.GetProperties(flags))
            {
                if (p.GetIndexParameters().Length > 0)
                    continue;

                if (!p.IsDefined(typeof(IgnoreDataMemberAttribute), true))
                    continue;

                set.Add(p.Name);

                // Also add renamed serialized names for ignored members (minimal, not a full map)
                if (p.TryGetAttribute<JsonPropertyNameAttribute>(true, out var stj) && stj.Name.HasValue())
                    set.Add(stj.Name);

                if (p.TryGetAttribute<DataMemberAttribute>(true, out var dm) && dm.Name.HasValue())
                    set.Add(dm.Name);

                if (p.TryGetAttribute<JsonPropertyAttribute>(true, out var nsj) && nsj.PropertyName.HasValue())
                    set.Add(nsj.PropertyName);
            }

            foreach (var f in t.GetFields(flags))
            {
                if (!f.IsDefined(typeof(IgnoreDataMemberAttribute), true))
                    continue;

                set.Add(f.Name);

                if (f.TryGetAttribute<JsonPropertyNameAttribute>(true, out var stj) && stj.Name.HasValue())
                    set.Add(stj.Name);

                if (f.TryGetAttribute<DataMemberAttribute>(true, out var dm) && dm.Name.HasValue())
                    set.Add(dm.Name);

                if (f.TryGetAttribute<JsonPropertyAttribute>(true, out var nsj) && nsj.PropertyName.HasValue())
                    set.Add(nsj.PropertyName);
            }

            return set;
        });
    }

    private static PropertyInfo GetMostDerivedProperty(Type rootType, string propertyName)
    {
        rootType = (rootType ?? typeof(object)).GetNonNullableType();

        var flags = BindingFlags.Instance | BindingFlags.Public;

        PropertyInfo best = null;
        var bestDistance = int.MaxValue;

        foreach (var p in rootType.GetProperties(flags))
        {
            if (p.GetIndexParameters().Length > 0)
                continue;

            // Do not pick interface-declared members
            if (p.DeclaringType != null && p.DeclaringType.IsInterface)
                continue;

            if (!string.Equals(p.Name, propertyName, StringComparison.OrdinalIgnoreCase))
                continue;

            var decl = p.DeclaringType;
            var dist = DistanceTo(rootType, decl);

            if (dist < bestDistance)
            {
                best = p;
                bestDistance = dist;
            }
        }

        return best;
    }
}




//using Microsoft.OpenApi.Any;
//using Microsoft.OpenApi.Models;
//using Swashbuckle.AspNetCore.SwaggerGen;

//namespace Smartstore.Web.Api.Swagger;

//internal class SwaggerExamplesSchemaFilter : ISchemaFilter
//{
//    const int MaxProperties = 500;

//    public void Apply(OpenApiSchema schema, SchemaFilterContext context)
//    {
//        // Only for object schemas with properties and for our domain models.
//        // If an explicit example already exists, do not overwrite it.
//        if (schema?.Properties == null
//            || schema.Properties.Count == 0
//            || context.Type?.Namespace == null
//            || !context.Type.Namespace.StartsWith("Smartstore.", StringComparison.Ordinal)
//            || schema.Example != null)
//        {
//            return;
//        }

//        var example = new OpenApiObject();
//        foreach (var (name, propSchema) in schema.Properties)
//        {
//            if (example.Count > MaxProperties)
//                break;

//            // Only primitive-ish properties
//            var any = CreatePrimitiveSample(propSchema);
//            if (any != null)
//            {
//                example[name] = any;
//            }
//        }

//        if (example.Count > 0)
//        {
//            schema.Example = example;
//        }
//    }

//    private static IOpenApiAny CreatePrimitiveSample(OpenApiSchema schema)
//    {
//        switch (schema?.Type ?? string.Empty)
//        {
//            case "boolean":
//                return new OpenApiBoolean(true);
//            case "integer":
//                return new OpenApiInteger(0);
//            case "number":
//                return new OpenApiDouble(0);
//            case "array":
//                return new OpenApiArray();
//            case "object":
//                return new OpenApiObject();
//        }

//        switch (schema?.Format ?? string.Empty)
//        {
//            case "date-time": 
//                return new OpenApiString("2026-01-01T00:00:00Z");
//            case "date": 
//                return new OpenApiString("2026-01-01");
//            case "uuid": 
//                return new OpenApiString("3fa85f64-5717-4562-b3fc-2c963f66afa6");
//            case "email": 
//                return new OpenApiString("user@example.com");
//            case "uri": 
//                return new OpenApiString("https://example.com");
//            case "byte": 
//                return new OpenApiByte(0);
//            default:
//                return new OpenApiString("string");
//        }
//    }
//}
