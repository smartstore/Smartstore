using System.Collections;
using System.Collections.Concurrent;
using System.Reflection;
using System.Runtime.Serialization;
using Microsoft.OpenApi.Any;
using Microsoft.OpenApi.Models;
using Swashbuckle.AspNetCore.SwaggerGen;

namespace Smartstore.Web.Api.Swagger;

/// <summary>
/// Generated by ChatGPT. Provides the JSON formatted examples in Swagger documentation.
/// Without this filter the example would display the whole schema graph, which is much to deep and impractical or unusable for humans.
/// </summary>
/// <remarks>Deepseek does not provide an adequate solution for this.</remarks>
internal sealed class SwaggerExamplesSchemaFilter : ISchemaFilter
{
    internal const int MaxDepth = 1;
    internal const int MaxPropsPerObject = 1000;
    internal const int MaxArrayItems = 1;

    // Extend as needed ("Foo*" supported)
    internal static readonly string[] ExcludedPropertyNamePatterns = ["UnderlyingEntities"];

    // Cache: CLR Type -> serializedName -> MemberInfo (Property/Field)
    private static readonly ConcurrentDictionary<Type, Dictionary<string, MemberInfo>> TypeMemberMapCache = new();

    public void Apply(OpenApiSchema schema, SchemaFilterContext context)
    {
        if (schema == null || context == null)
            return;

        // 1) Schema tab: never show any example (like Newtonsoft support did)
        schema.Example = null;

        // 2) Schema properties: remove ignored stuff (so it disappears from "Schema" property list)
        PruneSchemaProperties(schema, context.Type);
    }

    internal static IOpenApiAny BuildExample(OpenApiSchema rootSchema, SchemaRepository repo, Type rootClrType)
    {
        var visitedTypes = new HashSet<Type>();
        return BuildAny(rootSchema, repo, MaxDepth, UnwrapNullable(rootClrType) ?? typeof(object), visitedTypes);
    }

    private static IOpenApiAny BuildAny(OpenApiSchema schema, SchemaRepository repo, int depthRemaining, Type typeHint, HashSet<Type> visitedTypes)
    {
        schema = ResolveRef(schema, repo);

        var clrType = UnwrapNullable(typeHint) ?? typeof(object);

        if (depthRemaining < 0)
            return CompactPlaceholder(schema, repo, clrType);

        // Guard cycles only for complex entity-ish types
        if (ShouldGuardType(clrType))
        {
            if (!visitedTypes.Add(clrType))
                return CompactPlaceholder(schema, repo, clrType);

            try
            {
                return BuildAnyCore(schema, repo, depthRemaining, clrType, visitedTypes);
            }
            finally
            {
                visitedTypes.Remove(clrType);
            }
        }

        return BuildAnyCore(schema, repo, depthRemaining, clrType, visitedTypes);
    }

    private static IOpenApiAny BuildAnyCore(OpenApiSchema schema, SchemaRepository repo, int depthRemaining, Type clrType, HashSet<Type> visitedTypes)
    {
        if (schema != null && schema.Enum != null && schema.Enum.Count > 0)
            return schema.Enum[0];

        // Arrays/collections ALWAYS render as arrays (prevents Count/IsReadOnly/Length etc.)
        Type elementType;
        if (IsEnumerableLike(clrType, out elementType) || (schema != null && (schema.Type == "array" || schema.Items != null)))
        {
            var itemSchema = (schema != null && schema.Items != null) ? schema.Items : new OpenApiSchema { Type = "string" };
            var et = elementType ?? typeof(object);

            var arr = new OpenApiArray();
            for (var i = 0; i < MaxArrayItems; i++)
            {
                // Arrays do not consume depth
                arr.Add(BuildAny(itemSchema, repo, depthRemaining, et, visitedTypes));
            }
            return arr;
        }

        // Dictionary-like
        if (IsDictionaryLike(clrType) || (schema != null && schema.AdditionalProperties != null && (schema.Properties == null || schema.Properties.Count == 0)))
        {
            var obj = new OpenApiObject();
            obj["additionalProp1"] = new OpenApiString("string");
            obj["additionalProp2"] = new OpenApiString("string");
            return obj;
        }

        // primitives
        if (IsPrimitiveSchema(schema))
            return CreatePrimitiveExampleFromSchema(schema);

        if (IsSimpleClr(clrType))
            return CreatePrimitiveExampleFromClr(clrType, schema);

        // objects
        return BuildObjectExample(schema, repo, depthRemaining, clrType, visitedTypes);
    }

    private static OpenApiObject BuildObjectExample(OpenApiSchema schema, SchemaRepository repo, int depthRemaining, Type clrType, HashSet<Type> visitedTypes)
    {
        // additionalProperties-only
        if (schema != null &&
            schema.AdditionalProperties != null &&
            (schema.Properties == null || schema.Properties.Count == 0) &&
            (schema.AllOf == null || schema.AllOf.Count == 0))
        {
            var dict = new OpenApiObject();
            dict["additionalProp1"] = BuildAny(schema.AdditionalProperties, repo, depthRemaining - 1, typeof(object), visitedTypes);
            dict["additionalProp2"] = dict["additionalProp1"];
            return dict;
        }

        var props = GetEffectiveProperties(schema, repo);
        var memberMap = GetMemberMap(clrType);

        if (props == null || props.Count == 0)
        {
            // no schema props -> reflect CLR (still filtered)
            return BuildObjectFromReflection(clrType, repo, depthRemaining, visitedTypes);
        }

        var obj = new OpenApiObject();

        foreach (var kv in props.Take(MaxPropsPerObject))
        {
            var name = kv.Key;

            if (ShouldExcludeByName(name))
                continue;

            if (IsIgnoredByIgnoreDataMember(name, memberMap))
                continue;

            var memberType = GetMemberTypeHint(name, memberMap) ?? typeof(object);

            obj[name] = BuildAny(kv.Value, repo, depthRemaining - 1, memberType, visitedTypes);
        }

        return obj;
    }

    private static OpenApiObject BuildObjectFromReflection(Type clrType, SchemaRepository repo, int depthRemaining, HashSet<Type> visitedTypes)
    {
        clrType = UnwrapNullable(clrType) ?? typeof(object);

        Type _;
        if (IsEnumerableLike(clrType, out _) || IsDictionaryLike(clrType))
            return new OpenApiObject();

        if (depthRemaining < 0)
            return BuildCompactObjectFromClr(clrType);

        var flags = BindingFlags.Instance | BindingFlags.Public;
        var obj = new OpenApiObject();

        foreach (var p in clrType.GetProperties(flags))
        {
            if (obj.Count >= MaxPropsPerObject)
                break;

            if (p.GetIndexParameters().Length > 0)
                continue;

            // Do not include interface-declared members
            if (p.DeclaringType != null && p.DeclaringType.IsInterface)
                continue;

            if (p.IsDefined(typeof(IgnoreDataMemberAttribute), true))
                continue;

            if (ShouldExcludeByName(p.Name))
                continue;

            obj[p.Name] = BuildAny(new OpenApiSchema(), repo, depthRemaining - 1, p.PropertyType, visitedTypes);
        }

        return obj.Count > 0 ? obj : BuildCompactObjectFromClr(clrType);
    }

    private static IOpenApiAny CompactPlaceholder(OpenApiSchema schema, SchemaRepository repo, Type clrType)
    {
        Type elementType;
        if (IsEnumerableLike(clrType, out elementType) || (schema != null && (schema.Type == "array" || schema.Items != null)))
        {
            var arr = new OpenApiArray();
            if (MaxArrayItems > 0)
            {
                var itemSchema = (schema != null && schema.Items != null) ? schema.Items : new OpenApiSchema { Type = "string" };
                var et = elementType ?? typeof(object);

                if (IsSimpleClr(et))
                    arr.Add(CreatePrimitiveExampleFromClr(et, itemSchema));
                else
                    arr.Add(BuildCompactObjectFromClr(et));
            }
            return arr;
        }

        if (IsPrimitiveSchema(schema))
            return CreatePrimitiveExampleFromSchema(schema);

        if (IsSimpleClr(clrType))
            return CreatePrimitiveExampleFromClr(clrType, schema);

        return BuildCompactObjectFromClr(clrType);
    }

    private static OpenApiObject BuildCompactObjectFromClr(Type clrType)
    {
        var obj = new OpenApiObject();
        clrType = UnwrapNullable(clrType) ?? typeof(object);

        var flags = BindingFlags.Instance | BindingFlags.Public;

        var id = clrType.GetProperty("Id", flags);
        if (id != null && !id.IsDefined(typeof(IgnoreDataMemberAttribute), true) && !ShouldExcludeByName("Id"))
            obj["Id"] = CreatePrimitiveExampleFromClr(id.PropertyType, null);

        var name = clrType.GetProperty("Name", flags);
        if (name != null && !name.IsDefined(typeof(IgnoreDataMemberAttribute), true) && !ShouldExcludeByName("Name"))
            obj["Name"] = CreatePrimitiveExampleFromClr(name.PropertyType, null);

        return obj;
    }

    private static void PruneSchemaProperties(OpenApiSchema schema, Type clrType)
    {
        if (schema == null)
            return;

        if (schema.Properties == null || schema.Properties.Count == 0)
            return;

        clrType = UnwrapNullable(clrType) ?? typeof(object);

        // If the schema is actually a collection, don't treat it as object properties
        Type _;
        if (IsEnumerableLike(clrType, out _) || IsDictionaryLike(clrType))
            return;

        var memberMap = GetMemberMap(clrType);

        var toRemove = new List<string>();

        foreach (var kv in schema.Properties)
        {
            var name = kv.Key;

            if (ShouldExcludeByName(name))
            {
                toRemove.Add(name);
                continue;
            }

            if (IsIgnoredByIgnoreDataMember(name, memberMap))
            {
                toRemove.Add(name);
                continue;
            }
        }

        if (toRemove.Count == 0)
            return;

        for (var i = 0; i < toRemove.Count; i++)
        {
            schema.Properties.Remove(toRemove[i]);
            if (schema.Required != null)
                schema.Required.Remove(toRemove[i]);
        }
    }

    private static OpenApiSchema ResolveRef(OpenApiSchema schema, SchemaRepository repo)
    {
        if (schema == null || schema.Reference == null || string.IsNullOrWhiteSpace(schema.Reference.Id))
            return schema;

        if (repo != null && repo.Schemas != null && repo.Schemas.TryGetValue(schema.Reference.Id, out var resolved) && resolved != null)
            return resolved;

        return schema;
    }

    private static IDictionary<string, OpenApiSchema> GetEffectiveProperties(OpenApiSchema schema, SchemaRepository repo)
    {
        if (schema == null)
            return null;

        if (schema.Properties != null && schema.Properties.Count > 0)
            return schema.Properties;

        if (schema.AllOf == null || schema.AllOf.Count == 0)
            return schema.Properties;

        var merged = new Dictionary<string, OpenApiSchema>(StringComparer.OrdinalIgnoreCase);

        foreach (var part in schema.AllOf)
        {
            var s = ResolveRef(part, repo);
            if (s?.Properties == null)
                continue;

            foreach (var kv in s.Properties)
                merged[kv.Key] = kv.Value;
        }

        if (schema.Properties != null)
        {
            foreach (var kv in schema.Properties)
                merged[kv.Key] = kv.Value;
        }

        return merged.Count > 0 ? merged : null;
    }

    private static bool IsPrimitiveSchema(OpenApiSchema schema)
    {
        if (schema == null)
            return false;

        var type = schema.Type;
        return type == "string" || type == "integer" || type == "number" || type == "boolean";
    }

    private static IOpenApiAny CreatePrimitiveExampleFromSchema(OpenApiSchema schema)
    {
        var type = schema?.Type ?? "string";
        var format = schema?.Format ?? string.Empty;

        if (type == "boolean")
            return new OpenApiBoolean(true);

        if (type == "integer")
            return new OpenApiInteger(0);

        if (type == "number")
            return new OpenApiDouble(0);

        switch (format)
        {
            case "date-time": return new OpenApiString("2025-01-01T00:00:00Z");
            case "date": return new OpenApiString("2025-01-01");
            case "uuid": return new OpenApiString("3fa85f64-5717-4562-b3fc-2c963f66afa6");
            case "email": return new OpenApiString("user@example.com");
            case "uri": return new OpenApiString("https://example.com");
            default: return new OpenApiString("string");
        }
    }

    private static IOpenApiAny CreatePrimitiveExampleFromClr(Type t, OpenApiSchema schema)
    {
        t = UnwrapNullable(t) ?? typeof(string);

        if (t.IsEnum)
        {
            var names = Enum.GetNames(t);
            return new OpenApiString((names != null && names.Length > 0) ? names[0] : "Value");
        }

        if (t == typeof(bool))
            return new OpenApiBoolean(true);

        if (t == typeof(int) || t == typeof(long) || t == typeof(short) || t == typeof(byte))
            return new OpenApiInteger(0);

        if (t == typeof(float) || t == typeof(double) || t == typeof(decimal))
            return new OpenApiDouble(0);

        if (t == typeof(DateTime) || t == typeof(DateTimeOffset))
            return new OpenApiString("2025-01-01T00:00:00Z");

        if (t == typeof(Guid))
            return new OpenApiString("3fa85f64-5717-4562-b3fc-2c963f66afa6");

        if (t == typeof(Uri))
            return new OpenApiString("https://example.com");

        if (t == typeof(string) && schema != null && !string.IsNullOrWhiteSpace(schema.Format))
            return CreatePrimitiveExampleFromSchema(schema);

        return new OpenApiString("string");
    }

    private static bool IsEnumerableLike(Type t, out Type elementType)
    {
        elementType = null;
        if (t == null)
            return false;

        t = UnwrapNullable(t) ?? t;

        if (t == typeof(string))
            return false;

        if (IsDictionaryLike(t))
            return false;

        if (t.IsArray)
        {
            elementType = t.GetElementType() ?? typeof(object);
            return true;
        }

        foreach (var it in t.GetInterfaces())
        {
            if (it.IsGenericType && it.GetGenericTypeDefinition() == typeof(IEnumerable<>))
            {
                elementType = it.GetGenericArguments()[0];
                return true;
            }
        }

        if (typeof(IEnumerable).IsAssignableFrom(t))
        {
            elementType = typeof(object);
            return true;
        }

        return false;
    }

    private static bool IsDictionaryLike(Type t)
    {
        if (t == null)
            return false;

        t = UnwrapNullable(t) ?? t;

        if (typeof(IDictionary).IsAssignableFrom(t))
            return true;

        if (!t.IsGenericType)
            return false;

        var def = t.GetGenericTypeDefinition();
        return def == typeof(IDictionary<,>) || def == typeof(Dictionary<,>) || def == typeof(IReadOnlyDictionary<,>);
    }

    private static bool IsSimpleClr(Type t)
    {
        if (t == null)
            return false;

        t = UnwrapNullable(t) ?? t;

        if (t.IsEnum)
            return true;

        if (t.IsPrimitive)
            return true;

        return t == typeof(string)
               || t == typeof(decimal)
               || t == typeof(DateTime)
               || t == typeof(DateTimeOffset)
               || t == typeof(Guid)
               || t == typeof(Uri)
               || t == typeof(TimeSpan);
    }

    private static bool ShouldGuardType(Type t)
    {
        if (t == null || t == typeof(object))
            return false;

        if (IsSimpleClr(t))
            return false;

        Type _;
        if (IsEnumerableLike(t, out _) || IsDictionaryLike(t))
            return false;

        return t.IsClass;
    }

    private static Type UnwrapNullable(Type t)
    {
        if (t == null)
            return null;

        if (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(Nullable<>))
            return t.GetGenericArguments()[0];

        return t;
    }

    private static bool ShouldExcludeByName(string propertyName)
    {
        if (ExcludedPropertyNamePatterns == null || ExcludedPropertyNamePatterns.Length == 0)
            return false;

        for (var i = 0; i < ExcludedPropertyNamePatterns.Length; i++)
        {
            var p = ExcludedPropertyNamePatterns[i];
            if (string.IsNullOrWhiteSpace(p))
                continue;

            if (p.EndsWith("*", StringComparison.Ordinal))
            {
                var prefix = p.Substring(0, p.Length - 1);
                if (propertyName.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
                    return true;
            }
            else
            {
                if (string.Equals(propertyName, p, StringComparison.OrdinalIgnoreCase))
                    return true;
            }
        }

        return false;
    }

    // ---- IgnoreDataMember support (robust name mapping) ----

    private static Dictionary<string, MemberInfo> GetMemberMap(Type clrType)
    {
        clrType = UnwrapNullable(clrType) ?? typeof(object);

        return TypeMemberMapCache.GetOrAdd(clrType, static t =>
        {
            var map = new Dictionary<string, MemberInfo>(StringComparer.OrdinalIgnoreCase);
            var flags = BindingFlags.Instance | BindingFlags.Public;

            foreach (var p in t.GetProperties(flags))
            {
                if (p.GetIndexParameters().Length > 0)
                    continue;

                AddMemberNames(map, t, p, p.Name);
            }

            foreach (var f in t.GetFields(flags))
            {
                AddMemberNames(map, t, f, f.Name);
            }

            return map;
        });
    }

    private static void AddMemberNames(Dictionary<string, MemberInfo> map, Type rootType, MemberInfo member, string clrName)
    {
        AddOrReplaceMostDerived(map, rootType, clrName, member);

        // System.Text.Json: [JsonPropertyName("...")]
        var stj = member.GetCustomAttributes(inherit: true)
            .FirstOrDefault(a => a.GetType().FullName == "System.Text.Json.Serialization.JsonPropertyNameAttribute");
        if (stj != null)
        {
            var nameProp = stj.GetType().GetProperty("Name", BindingFlags.Instance | BindingFlags.Public);
            var n = nameProp?.GetValue(stj) as string;
            if (!string.IsNullOrWhiteSpace(n))
                AddOrReplaceMostDerived(map, rootType, n, member);
        }

        // DataContract: [DataMember(Name="...")]
        var dm = member.GetCustomAttribute<DataMemberAttribute>(inherit: true);
        if (!string.IsNullOrWhiteSpace(dm?.Name))
            AddOrReplaceMostDerived(map, rootType, dm.Name, member);

        // Newtonsoft (optional): [JsonProperty(PropertyName="...")]
        var nsj = member.GetCustomAttributes(inherit: true)
            .FirstOrDefault(a => a.GetType().FullName == "Newtonsoft.Json.JsonPropertyAttribute");
        if (nsj != null)
        {
            var pn = nsj.GetType().GetProperty("PropertyName", BindingFlags.Instance | BindingFlags.Public);
            var n = pn?.GetValue(nsj) as string;
            if (!string.IsNullOrWhiteSpace(n))
                AddOrReplaceMostDerived(map, rootType, n, member);
        }
    }

    private static void AddOrReplaceMostDerived(Dictionary<string, MemberInfo> map, Type rootType, string key, MemberInfo candidate)
    {
        if (!map.TryGetValue(key, out var existing) || existing == null)
        {
            map[key] = candidate;
            return;
        }

        var candDecl = candidate.DeclaringType;
        var existDecl = existing.DeclaringType;

        if (candDecl == null || existDecl == null)
            return;

        if (existDecl.IsAssignableFrom(candDecl))
        {
            map[key] = candidate;
            return;
        }

        var dc = DistanceTo(rootType, candDecl);
        var de = DistanceTo(rootType, existDecl);
        if (dc < de)
            map[key] = candidate;
    }

    private static int DistanceTo(Type rootType, Type declaringType)
    {
        var d = 0;
        for (var t = rootType; t != null; t = t.BaseType, d++)
        {
            if (t == declaringType)
                return d;
        }
        return int.MaxValue;
    }

    private static bool IsIgnoredByIgnoreDataMember(string schemaPropertyName, Dictionary<string, MemberInfo> memberMap)
    {
        if (memberMap == null)
            return false;

        if (!memberMap.TryGetValue(schemaPropertyName, out var mi) || mi == null)
            return false;

        return mi.IsDefined(typeof(IgnoreDataMemberAttribute), true);
    }

    private static Type GetMemberTypeHint(string schemaPropertyName, Dictionary<string, MemberInfo> memberMap)
    {
        if (memberMap == null)
            return null;

        if (!memberMap.TryGetValue(schemaPropertyName, out var mi) || mi == null)
            return null;

        if (mi is PropertyInfo pi)
            return pi.PropertyType;

        if (mi is FieldInfo fi)
            return fi.FieldType;

        return null;
    }
}




//using Microsoft.OpenApi.Any;
//using Microsoft.OpenApi.Models;
//using Swashbuckle.AspNetCore.SwaggerGen;

//namespace Smartstore.Web.Api.Swagger;

//internal class SwaggerExampleSchemaFilter : ISchemaFilter
//{
//    const int MaxProperties = 1000;

//    public void Apply(OpenApiSchema schema, SchemaFilterContext context)
//    {
//        // Only for object schemas with properties
//        if (schema?.Properties == null || schema.Properties.Count == 0)
//            return;

//        // Keep it conservative: only attach examples for your domain models
//        // (adjust namespace prefix to your solution)
//        if (context.Type?.Namespace == null || !context.Type.Namespace.StartsWith("Smartstore.", StringComparison.Ordinal))
//            return;

//        // If an explicit example already exists, don't overwrite it
//        if (schema.Example != null)
//            return;

//        var example = new OpenApiObject();
//        foreach (var (name, propSchema) in schema.Properties)
//        {
//            if (example.Count >= MaxProperties)
//                break;

//            // Only primitive-ish properties
//            var any = CreatePrimitiveSample(propSchema);
//            if (any != null)
//            {
//                example[name] = any;
//            }
//        }

//        if (example.Count > 0)
//        {
//            schema.Example = example;
//        }
//    }

//    private static IOpenApiAny CreatePrimitiveSample(OpenApiSchema prop)
//    {
//        return prop.Type switch
//        {
//            "string" => new OpenApiString(prop.Format == "date-time" ? "2025-01-01T00:00:00Z" : "string"),
//            "integer" => new OpenApiInteger(0),
//            "number" => new OpenApiDouble(0),
//            "boolean" => new OpenApiBoolean(true),
//            _ => null
//        };
//    }
//}
