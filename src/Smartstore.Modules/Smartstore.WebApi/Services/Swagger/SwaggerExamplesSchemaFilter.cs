using System.Collections.Concurrent;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.Json.Serialization;
using Microsoft.OpenApi.Any;
using Microsoft.OpenApi.Models;
using Newtonsoft.Json;
using Swashbuckle.AspNetCore.SwaggerGen;

namespace Smartstore.Web.Api.Swagger;

/* 
 TODO: (mg) 
    - INFO: Never copy/paste AI generated code without checking and adjusting to our common coding practices!
    - Very bad architecture:
        - TypeMemberMapCache is far too greedy and cosumes memory for all types ever processed, BUT...
        - ... PruneSchemaProperties() ALWAYS processes attributes and checks other stuff on demand. What is caching good for then?!
        - Everything belongs to the cache, or don't cache at all! Or cache only the minimum needed info (e.g. ignored properties only).
        - DRY: IgnoreDataMember, DataMember and other stuff are already processed by SmartJsonOption.WithDataContractModifiers(),
          so ideally we should reuse that info instead of re-reflecting everything here again?
            - To access that info, we call JsonSerializerOptions.GetTypeInfo(type) (we obtain the options via DI: IOptions<JsonOptions>.Value...)
            - But then, the originally lazy-loaded JSON type resolution will process EVERY type on startup, killing startup performance? Hmmm...?
        - How do you distinguish between SwaggerSchemaFilter and SwaggerExamplesSchemaFilter (how do you know that we are processing "Examples" right now?)?
        - Sometimes SingleResult<T> is pruned. Unwrapping fail?
        - Maybe SmartSerializerDataContractResolver is the better place to hook into? Hmmm...
    - NiceToHave: Consider using some [SwaggerSchemaExample] attributes on properties to override examples on a per-property basis.
 */

/// <summary>
/// Generated by ChatGPT. Provides the JSON formatted examples in Swagger documentation.
/// Without this filter the example would display the whole schema graph, which is much to deep and impractical or unusable for humans.
/// </summary>
/// <remarks>Deepseek does not provide an adequate solution for this.</remarks>
internal sealed class SwaggerExamplesSchemaFilter : ISchemaFilter
{
    internal const int MaxDepth = 1;
    internal const int MaxPropsPerObject = 1000;
    internal const int MaxArrayItems = 1;

    // Extend as needed ("Foo*" supported)
    internal static readonly string[] ExcludedPropertyNamePatterns = ["UnderlyingEntities"];

    // Cache: CLR Type -> serializedName -> MemberInfo (Property/Field)
    private static readonly ConcurrentDictionary<Type, Dictionary<string, MemberInfo>> TypeMemberMapCache = new();

    public void Apply(OpenApiSchema schema, SchemaFilterContext context)
    {
        if (schema == null || context == null)
            return;

        // 1) Schema tab: never show any example (like Newtonsoft support did)
        // TODO: (mg) I don't see any difference in Swagger-UI-behaviour between NSJ and STJ. Hmmm...
        schema.Example = null;

        // 2) Schema properties: remove ignored stuff (so it disappears from "Schema" property list)
        PruneSchemaProperties(schema, context.Type);
    }

    internal static IOpenApiAny BuildExample(OpenApiSchema rootSchema, SchemaRepository repo, Type rootClrType)
    {
        var visitedTypes = new HashSet<Type>();
        return BuildAny(rootSchema, repo, MaxDepth, (rootClrType ?? typeof(object)).GetNonNullableType(), visitedTypes);
    }

    private static IOpenApiAny BuildAny(OpenApiSchema schema, SchemaRepository repo, int depthRemaining, Type typeHint, HashSet<Type> visitedTypes)
    {
        schema = ResolveRef(schema, repo);

        var clrType = (typeHint ?? typeof(object)).GetNonNullableType();

        if (depthRemaining < 0)
            return CompactPlaceholder(schema, repo, clrType);

        // Guard cycles only for complex entity-ish types
        if (ShouldGuardType(clrType))
        {
            if (!visitedTypes.Add(clrType))
                return CompactPlaceholder(schema, repo, clrType);

            try
            {
                return BuildAnyCore(schema, repo, depthRemaining, clrType, visitedTypes);
            }
            finally
            {
                visitedTypes.Remove(clrType);
            }
        }

        return BuildAnyCore(schema, repo, depthRemaining, clrType, visitedTypes);
    }

    private static IOpenApiAny BuildAnyCore(OpenApiSchema schema, SchemaRepository repo, int depthRemaining, Type clrType, HashSet<Type> visitedTypes)
    {
        if (schema?.Enum != null && schema.Enum.Count > 0)
            return schema.Enum[0];

        // Arrays/collections ALWAYS render as arrays (prevents Count/IsReadOnly/Length etc.)
        if (clrType.IsSequenceType(out var elementType) || (schema != null && (schema.Type == "array" || schema.Items != null)))
        {
            var itemSchema = (schema != null && schema.Items != null) ? schema.Items : new OpenApiSchema { Type = "string" };
            var et = elementType ?? typeof(object);

            var arr = new OpenApiArray();
            for (var i = 0; i < MaxArrayItems; i++)
            {
                // Arrays do not consume depth
                arr.Add(BuildAny(itemSchema, repo, depthRemaining, et, visitedTypes));
            }
            return arr;
        }

        // Dictionary-like
        if (clrType.IsDictionaryType() || (schema != null && schema.AdditionalProperties != null && (schema.Properties == null || schema.Properties.Count == 0)))
        {
            var obj = new OpenApiObject
            {
                ["additionalProp1"] = new OpenApiString("string"),
                ["additionalProp2"] = new OpenApiString("string")
            };
            return obj;
        }

        // primitives
        if (IsPrimitiveSchema(schema))
            return CreatePrimitiveExampleFromSchema(schema);

        if (IsSimpleClr(clrType))
            return CreatePrimitiveExampleFromClr(clrType, schema);

        // objects
        return BuildObjectExample(schema, repo, depthRemaining, clrType, visitedTypes);
    }

    private static OpenApiObject BuildObjectExample(OpenApiSchema schema, SchemaRepository repo, int depthRemaining, Type clrType, HashSet<Type> visitedTypes)
    {
        // additionalProperties-only
        if (schema != null &&
            schema.AdditionalProperties != null &&
            (schema.Properties == null || schema.Properties.Count == 0) &&
            (schema.AllOf == null || schema.AllOf.Count == 0))
        {
            var dict = new OpenApiObject
            {
                ["additionalProp1"] = BuildAny(schema.AdditionalProperties, repo, depthRemaining - 1, typeof(object), visitedTypes)
            };
            dict["additionalProp2"] = dict["additionalProp1"];
            return dict;
        }

        var props = GetEffectiveProperties(schema, repo);
        var memberMap = GetMemberMap(clrType);

        if (props == null || props.Count == 0)
        {
            // no schema props -> reflect CLR (still filtered)
            return BuildObjectFromReflection(clrType, repo, depthRemaining, visitedTypes);
        }

        var obj = new OpenApiObject();

        foreach (var kvp in props.Take(MaxPropsPerObject))
        {
            var name = kvp.Key;

            if (ShouldExcludeByName(name))
                continue;

            if (IsIgnoredMember(name, memberMap))
                continue;

            var memberType = GetMemberTypeHint(name, memberMap) ?? typeof(object);

            obj[name] = BuildAny(kvp.Value, repo, depthRemaining - 1, memberType, visitedTypes);
        }

        return obj;
    }

    private static OpenApiObject BuildObjectFromReflection(Type clrType, SchemaRepository repo, int depthRemaining, HashSet<Type> visitedTypes)
    {
        clrType = (clrType ?? typeof(object)).GetNonNullableType();

        if (clrType.IsSequenceType() || clrType.IsDictionaryType())
            return new OpenApiObject();

        if (depthRemaining < 0)
            return BuildCompactObjectFromClr(clrType);

        var flags = BindingFlags.Instance | BindingFlags.Public;
        var obj = new OpenApiObject();

        foreach (var p in clrType.GetProperties(flags))
        {
            if (obj.Count >= MaxPropsPerObject)
                break;

            if (p.GetIndexParameters().Length > 0)
                continue;

            // Do not include interface-declared members
            if (p.DeclaringType != null && p.DeclaringType.IsInterface)
                continue;

            if (p.IsDefined(typeof(IgnoreDataMemberAttribute), true))
                continue;

            if (ShouldExcludeByName(p.Name))
                continue;

            obj[p.Name] = BuildAny(new OpenApiSchema(), repo, depthRemaining - 1, p.PropertyType, visitedTypes);
        }

        return obj.Count > 0 ? obj : BuildCompactObjectFromClr(clrType);
    }

    private static IOpenApiAny CompactPlaceholder(OpenApiSchema schema, SchemaRepository repo, Type clrType)
    {
        if (clrType.IsSequenceType(out var elementType) || (schema != null && (schema.Type == "array" || schema.Items != null)))
        {
            var arr = new OpenApiArray();
            if (MaxArrayItems > 0)
            {
                var itemSchema = (schema != null && schema.Items != null) ? schema.Items : new OpenApiSchema { Type = "string" };
                var et = elementType ?? typeof(object);

                if (IsSimpleClr(et))
                    arr.Add(CreatePrimitiveExampleFromClr(et, itemSchema));
                else
                    arr.Add(BuildCompactObjectFromClr(et));
            }
            return arr;
        }

        if (IsPrimitiveSchema(schema))
            return CreatePrimitiveExampleFromSchema(schema);

        if (IsSimpleClr(clrType))
            return CreatePrimitiveExampleFromClr(clrType, schema);

        return BuildCompactObjectFromClr(clrType);
    }

    private static OpenApiObject BuildCompactObjectFromClr(Type clrType)
    {
        var obj = new OpenApiObject();
        clrType = (clrType ?? typeof(object)).GetNonNullableType();

        var flags = BindingFlags.Instance | BindingFlags.Public;

        var id = clrType.GetProperty("Id", flags);
        if (id != null && !id.IsDefined(typeof(IgnoreDataMemberAttribute), true) && !ShouldExcludeByName("Id"))
            obj["Id"] = CreatePrimitiveExampleFromClr(id.PropertyType, null);

        var name = clrType.GetProperty("Name", flags);
        if (name != null && !name.IsDefined(typeof(IgnoreDataMemberAttribute), true) && !ShouldExcludeByName("Name"))
            obj["Name"] = CreatePrimitiveExampleFromClr(name.PropertyType, null);

        return obj;
    }

    private static void PruneSchemaProperties(OpenApiSchema schema, Type clrType)
    {
        if (schema == null || clrType == null)
            return;

        if (schema.Properties == null || schema.Properties.Count == 0)
            return;

        // If the schema is actually a collection, don't treat it as object properties
        if (clrType.IsSequenceType() || clrType.IsDictionaryType())
            return;

        clrType = clrType.GetNonNullableType();

        var memberMap = GetMemberMap(clrType);

        var toRemove = new List<string>();

        foreach (var kv in schema.Properties)
        {
            var name = kv.Key;

            if (ShouldExcludeByName(name))
            {
                toRemove.Add(name);
                continue;
            }

            if (IsIgnoredMember(name, memberMap))
            {
                toRemove.Add(name);
                continue;
            }
        }

        if (toRemove.Count == 0)
            return;

        for (var i = 0; i < toRemove.Count; i++)
        {
            schema.Properties.Remove(toRemove[i]);
            schema.Required?.Remove(toRemove[i]);
        }
    }

    private static OpenApiSchema ResolveRef(OpenApiSchema schema, SchemaRepository repo)
    {
        if (schema?.Reference == null || schema.Reference.Id.IsEmpty())
            return schema;

        if (repo?.Schemas != null && repo.Schemas.TryGetValue(schema.Reference.Id, out var resolved) && resolved != null)
            return resolved;

        return schema;
    }

    private static IDictionary<string, OpenApiSchema> GetEffectiveProperties(OpenApiSchema schema, SchemaRepository repo)
    {
        if (schema == null)
            return null;

        if (schema.Properties != null && schema.Properties.Count > 0)
            return schema.Properties;

        if (schema.AllOf == null || schema.AllOf.Count == 0)
            return schema.Properties;

        var merged = new Dictionary<string, OpenApiSchema>(StringComparer.OrdinalIgnoreCase);

        foreach (var part in schema.AllOf)
        {
            var s = ResolveRef(part, repo);
            if (s?.Properties == null)
                continue;

            merged.Merge(s.Properties);
        }

        if (schema.Properties != null)
        {
            merged.Merge(schema.Properties);
        }

        return merged.Count > 0 ? merged : null;
    }

    private static bool IsPrimitiveSchema(OpenApiSchema schema)
    {
        if (schema == null)
            return false;

        var type = schema.Type;
        return type == "string" || type == "integer" || type == "number" || type == "boolean";
    }

    private static IOpenApiAny CreatePrimitiveExampleFromSchema(OpenApiSchema schema)
    {
        var type = schema?.Type ?? "string";
        var format = schema?.Format ?? string.Empty;

        if (type == "boolean")
            return new OpenApiBoolean(true);

        if (type == "integer")
            return new OpenApiInteger(0);

        if (type == "number")
            return new OpenApiDouble(0);

        switch (format)
        {
            case "date-time": return new OpenApiString("2025-01-01T00:00:00Z");
            case "date": return new OpenApiString("2025-01-01");
            case "uuid": return new OpenApiString("3fa85f64-5717-4562-b3fc-2c963f66afa6");
            case "email": return new OpenApiString("user@example.com");
            case "uri": return new OpenApiString("https://example.com");
            default: return new OpenApiString("string");
        }
    }

    private static IOpenApiAny CreatePrimitiveExampleFromClr(Type t, OpenApiSchema schema)
    {
        t = (t ?? typeof(string)).GetNonNullableType();

        if (t.IsEnum)
        {
            var names = Enum.GetNames(t);
            return new OpenApiString(names.FirstOrDefault() ?? "Value");
        }

        if (t == typeof(bool))
            return new OpenApiBoolean(true);

        if (t == typeof(int) || t == typeof(long) || t == typeof(short) || t == typeof(byte))
            return new OpenApiInteger(0);

        if (t == typeof(float) || t == typeof(double) || t == typeof(decimal))
            return new OpenApiDouble(0);

        if (t == typeof(DateTime) || t == typeof(DateTimeOffset))
            return new OpenApiString("2025-01-01T00:00:00Z");

        if (t == typeof(Guid))
            return new OpenApiString("3fa85f64-5717-4562-b3fc-2c963f66afa6");

        if (t == typeof(Uri))
            return new OpenApiString("https://example.com");

        if (t == typeof(string) && schema != null && !string.IsNullOrWhiteSpace(schema.Format))
            return CreatePrimitiveExampleFromSchema(schema);

        return new OpenApiString("string");
    }

    private static bool IsSimpleClr(Type t)
    {
        if (t == null)
            return false;

        t = t.GetNonNullableType();

        if (t == typeof(Uri))
            return true;

        return t.IsBasicType() && t != typeof(byte[]);
    }

    private static bool ShouldGuardType(Type t)
    {
        if (t == null || t == typeof(object))
            return false;

        if (IsSimpleClr(t))
            return false;

        if (t.IsSequenceType() || t.IsDictionaryType())
            return false;

        return t.IsClass;
    }

    private static bool ShouldExcludeByName(string propertyName)
    {
        if (ExcludedPropertyNamePatterns == null || ExcludedPropertyNamePatterns.Length == 0)
            return false;

        for (var i = 0; i < ExcludedPropertyNamePatterns.Length; i++)
        {
            var p = ExcludedPropertyNamePatterns[i];
            if (p.IsEmpty())
                continue;

            if (p.EndsWith('*'))
            {
                var prefix = p[..^1];
                if (propertyName.StartsWithNoCase(prefix))
                    return true;
            }
            else
            {
                if (propertyName.EqualsNoCase(p))
                    return true;
            }
        }

        return false;
    }

    private static Dictionary<string, MemberInfo> GetMemberMap(Type clrType)
    {
        clrType = (clrType ?? typeof(object)).GetNonNullableType();

        //var jsonOptions = EngineContext.Current.Application.Services.Resolve<IOptions<JsonOptions>>().Value.JsonSerializerOptions;
        //var typeInfo = jsonOptions.GetTypeInfo(clrType);
        //var props = typeInfo.Properties;
        //var propMap = props.ToDictionary(p => p.Name, p => p, StringComparer.OrdinalIgnoreCase);

        return TypeMemberMapCache.GetOrAdd(clrType, static t =>
        {
            var map = new Dictionary<string, MemberInfo>(StringComparer.OrdinalIgnoreCase);
            var flags = BindingFlags.Instance | BindingFlags.Public;

            foreach (var p in t.GetProperties(flags))
            {
                if (p.GetIndexParameters().Length > 0)
                    continue;

                AddMemberNames(map, t, p, p.Name);
            }

            foreach (var f in t.GetFields(flags))
            {
                AddMemberNames(map, t, f, f.Name);
            }

            return map;
        });
    }

    private static void AddMemberNames(Dictionary<string, MemberInfo> map, Type rootType, MemberInfo member, string clrName)
    {
        AddOrReplaceMostDerived(map, rootType, clrName, member);
        
        if (member.TryGetAttribute<JsonPropertyNameAttribute>(true, out var propName) && propName.Name.HasValue())
        {
            AddOrReplaceMostDerived(map, rootType, propName.Name, member);
        }
        else if (member.TryGetAttribute<DataMemberAttribute>(true, out var dataMember) && dataMember.Name.HasValue())
        {
            AddOrReplaceMostDerived(map, rootType, dataMember.Name, member);
        }
        else if (member.TryGetAttribute<JsonPropertyAttribute>(true, out var prop) && prop.PropertyName.HasValue())
        {
            AddOrReplaceMostDerived(map, rootType, prop.PropertyName, member);
        }
    }

    private static void AddOrReplaceMostDerived(Dictionary<string, MemberInfo> map, Type rootType, string key, MemberInfo candidate)
    {
        if (!map.TryGetValue(key, out var existing) || existing == null)
        {
            map[key] = candidate;
            return;
        }

        var candDecl = candidate.DeclaringType;
        var existDecl = existing.DeclaringType;

        if (candDecl == null || existDecl == null)
            return;

        if (existDecl.IsAssignableFrom(candDecl))
        {
            map[key] = candidate;
            return;
        }

        var dc = DistanceTo(rootType, candDecl);
        var de = DistanceTo(rootType, existDecl);
        if (dc < de)
            map[key] = candidate;
    }

    private static int DistanceTo(Type rootType, Type declaringType)
    {
        var d = 0;
        for (var t = rootType; t != null; t = t.BaseType, d++)
        {
            if (t == declaringType)
                return d;
        }
        return int.MaxValue;
    }

    private static bool IsIgnoredMember(string schemaPropertyName, Dictionary<string, MemberInfo> memberMap)
    {
        if (memberMap == null)
            return false;

        if (!memberMap.TryGetValue(schemaPropertyName, out var mi) || mi == null)
            return false;

        if (mi.IsDefined(typeof(IgnoreDataMemberAttribute), true)) 
        {
            return true;
        }

        if (mi.TryGetAttribute<System.Text.Json.Serialization.JsonIgnoreAttribute>(true, out var attr))
        {
            return attr.Condition is (JsonIgnoreCondition.Always or JsonIgnoreCondition.WhenWriting);
        }

        if (mi.HasAttribute<Newtonsoft.Json.JsonIgnoreAttribute>(true))
        {
            return true;
        }

        return false;
    }

    private static Type GetMemberTypeHint(string schemaPropertyName, Dictionary<string, MemberInfo> memberMap)
    {
        if (memberMap == null)
            return null;

        if (!memberMap.TryGetValue(schemaPropertyName, out var mi) || mi == null)
            return null;

        if (mi is PropertyInfo pi)
            return pi.PropertyType;

        if (mi is FieldInfo fi)
            return fi.FieldType;

        return null;
    }
}




//using Microsoft.OpenApi.Any;
//using Microsoft.OpenApi.Models;
//using Swashbuckle.AspNetCore.SwaggerGen;

//namespace Smartstore.Web.Api.Swagger;

//internal class SwaggerExampleSchemaFilter : ISchemaFilter
//{
//    const int MaxProperties = 1000;

//    public void Apply(OpenApiSchema schema, SchemaFilterContext context)
//    {
//        // Only for object schemas with properties
//        if (schema?.Properties == null || schema.Properties.Count == 0)
//            return;

//        // Keep it conservative: only attach examples for your domain models
//        // (adjust namespace prefix to your solution)
//        if (context.Type?.Namespace == null || !context.Type.Namespace.StartsWith("Smartstore.", StringComparison.Ordinal))
//            return;

//        // If an explicit example already exists, don't overwrite it
//        if (schema.Example != null)
//            return;

//        var example = new OpenApiObject();
//        foreach (var (name, propSchema) in schema.Properties)
//        {
//            if (example.Count >= MaxProperties)
//                break;

//            // Only primitive-ish properties
//            var any = CreatePrimitiveSample(propSchema);
//            if (any != null)
//            {
//                example[name] = any;
//            }
//        }

//        if (example.Count > 0)
//        {
//            schema.Example = example;
//        }
//    }

//    private static IOpenApiAny CreatePrimitiveSample(OpenApiSchema prop)
//    {
//        return prop.Type switch
//        {
//            "string" => new OpenApiString(prop.Format == "date-time" ? "2025-01-01T00:00:00Z" : "string"),
//            "integer" => new OpenApiInteger(0),
//            "number" => new OpenApiDouble(0),
//            "boolean" => new OpenApiBoolean(true),
//            _ => null
//        };
//    }
//}
